# 能源预算项目

页面与方法分离，

## 一、hightcharts总结

### 对比柱图----案例

```html
    <script type="text/javascript">
     $(function(){
	    var chartId = document.getElementById("chartxxxx");
        console.log(chartId);
        var lineNameChart2 = columnComparisonChart(chartId);
        lineNameChartData(lineNameChart2);
	});
       //给Chart赋值
        function lineNameChartData(thisChart) {
            var len = thisChart.series.length;
            console.log(len)
            for (var j = 0; j < len; i++) {
                var arr = [];
                for (var j = 0; j < 24; j++) {
                    var item = { x: j, y: Math.random() }
                    arr.push(item);
                }
                thisChart.series[i].setData(arr);
                console.log(arr);
            }
        };
        //chart
        function columnComparisonChart(itemId) {
            var chart = new Highcharts.Chart({
                chart: {
                    renderTo: itemId,
                    backgroundColor: "rgba(0,0,0,0)",
                    spacingTop: 44,
                    spacingRight: 20
                },
                exporting: {
                    enabled: false//导出模块
                },
                credits: {//版权的一些事
                    enabled: false
                },
                legend: {//图例说明是包含图表中数列标志和名称的容器。
                    enabled: false,
                },
                title: {
                    text: null
                },
                //x轴设置
                xAxis: {
                    startOnTick: true,//是否强制轴线在标线处开始
                    endOnTick: true,//结束于标线；是否强制轴线在标线处结束
                    maxPadding: 0,
                    lineWidth: 1, //刻度线整条线的长度
                    tickInterval:2,  //坐标轴密度
                    tickColor: '#ccc',
                    tickLength: 6,
                    tickmarkPlacement: 'on',
                    minorTickLength: 1,
                    labels: {
                        style: {
                            fontFamily: 'Arial,"微软雅黑",sans-serif'
                        },
                        formatter: function () {
                            // console.log(this.value)
                            var xdate =(new Date()).getHours();
                            console.log(xdate)
                            return xdate;
							// return xdate.format('h:m');
                        },
                        enabled: true,
                        //staggerLines: 1//分几行显示x轴
                    },
                    type: 'datetime',
                },
                yAxis: [{ // left y axis
                    title: {
                        text: null,
                    },
                    gridLineColor: '#dddddd',//x轴网格线的颜色
                    gridLineDashStyle: 'ShortDash',//x轴网格线的样式
                    gridLineWidth: 1,//x轴网格线
                    endOnTick: true,
                    labels: {
                        style: {
                            fontFamily: 'Arial,"微软雅黑",sans-serif'
                        },
                    },
                    //showFirstLabel: false
                }],
                tooltip: {
                    enabled: true,
                    animation: true,
                    borderColor: null,
                    borderWidth: 0,
                    shadow: false,
                    backgroundColor: null,
                    useHTML: true,
                    shared: true,
                    style: {
                        fontFamily: 'Arial,"微软雅黑",sans-serif'
                    },
                    crosshairs: {
                        width: 1,
                        color: 'gray',
                        dashStyle: 'shortdot'
                    },
                    formatter: function () {
                        var html = '', name = '', val = '';
                        for (var i = 0; i < this.points.length; i++) {
                            name = this.points[i].series.name;
                            val = this.points[i].y;
                            html += '<span>' + name + '：' + val + 'kWH</span>'
                        }
                        return '<span>' + this.x + '</span>' + html;
                    }
                },
                plotOptions: {//绘图区选项
                    series: {//绘图区数列
                        connectNulls: false,//是否连接一条线穿过空值点。
                        stickyTracking: false,//粘连追踪
                    }
                },
                series: [
                    {
                        name: '实测能耗',
                        type: 'column',
                        color: "#02a9d1",
                    }, {
                        name: '能耗计划',
                        type: 'line',
                        zIndex: 3,
                        dashStyle: 'ShortDash',
                        marker: {
                            enabled: true,
                            radius: 4,
                            fillColor: '#fff',
                            lineColor: null,
                            lineWidth: 1,
                            symbol: 'circle',//标记点的样子"circle", "square", "diamond", "triangle" and "triangle-down"还可以自定义'pointCircle'.'url(../img/weatherPic/0_small.png)'
                            states: {
                                hover: {
                                    enabled: false,
                                }
                            },
                        },
                        color: '#8098b0',
                    }]
            });
            return chart;
        }
    </script>
```

### 图表自适应问题

**reflow()函数**

### 实现图表的联动

**chart.tooltip.refresh(chart.series[0].points[0])**

## 二、用到的小函数

### 1.转换百分数保留两位小数

```
toPercent: function (point){
        var str=Number(point*100);
        str+="%";
        return str;
}
```

2.封装好的方法

```

```



## 三、vue的一些东西

### vue的子组件props更新

```
// 子组件
<template>
  <div class="hello">
    <ul>
      <!-- 此处comp 来自 computed -->
      <li v-for="i in comp" :key='i'>{{i}}</li>
    </ul>
  </div>
</template>

<script>
export default {
  props:['info'],
  computed: {
    comp (){
      return this.info.map(i => '0_'+i)
    }
  },
}
</script>
```
**注意：绑定在props上的属性 需要小写**

```
Vue.component('blog-post', {
  // 在 JavaScript 中是 camelCase 的
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
<!-- 在 HTML 中是 kebab-case 的 -->
<blog-post post-title="hello!"></blog-post>
```

### vue的计算属性（computed ）

网址：<https://cn.vuejs.org/v2/guide/computed.html> 

使用场景：对于任何复杂逻辑，你都应当使用**计算属性** 

```
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 

```
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
```

### vue在v-text中写过滤器

- 使用全局方法
- 使用 computed 属性
- 使用 $options.filters

例如 ：

```
1.使用全局方法
Vue.prototype.highlight= function (sTitle) {
  // to do
};
v-html="highlight(option.title)"
2.可以使用计算属性 computed，返回原生 html 给 v-html 即可。
3.使用 $options.filters
$options.filters.discount(item.realOccupyPlanRatio)  //使用 $options.filters
```

### vue全局过滤器的优化

```
我们可以抽出到独立文件，然后使用 Object.keys 在 main.js 入口统一注册
/src/common/filters.js

let dateServer = value => value.replace(/(\d{4})(\d{2})(\d{2})/g, "$1-$2-$3");
export { dateServer };

/src/main.js

import * as custom from "./common/filters/custom";
Object.keys(custom).forEach(key => Vue.filter(key, custom[key]));

然后在其他的.vue 文件中就可愉快地使用这些我们定义好的全局过滤器了


<template>
  <section class="content">
    <p>{{ time | dateServer }}</p> <!-- 2016-01-01 -->
  </section>
</template>
<script>
  export default {
    data () {
      return {
        time: 20160101
      }
    }
  }
</script>
```

### vuex随笔

```
vuex 是一个专门为vue.js应用程序开发的状态管理模式。
```

**vuex中，有默认的五种基本的对象：**

- state：存储状态（变量）
- getters：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()
- mutations：修改状态，并且是同步的。在组件中使用$store.commit('',params)。这个和我们组件中的自定义事件类似。
- actions：异步操作。在组件中使用是$store.dispath('')
- modules：store的子模块，为了开发大型项目，方便状态管理而使用的。这里我们就不解释了，用起来和上面的一样。

```
vue init webpack app
cd app/
npm run dev
npm install vuex --save
```

在store.js文件中，引入vuex并且使用vuex，这里注意我的变量名是大写Vue和Vuex　 

```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const state = {
    count: 0
}

export default new Vuex.Store({
    state
})
```

接下来，在main.js中引入store 

```
import Vue from 'vue'
import App from './App'
import router from './router'
import store from './vuex/store' // 引入store
Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
    el: '#app',
    router,
    store,
    components: { App },
    template: '<App/>'
})
```

**在组件中使用count**

```
<template>
  <div class="hello">
    <h3>{{$store.state.count}}</h3>
  </div>
</template>
```

#### 1.Vuex.Store中使用**mutations**

```
/**
 * mutations 里面放置的是我们操作state对象属性的方法
 */
const mutations = {
    mutationsAddCount(state, n = 0) {
        return (state.count += n)
    },
    mutationsReduceCount(state, n = 0) {
        return (state.count -= n)
    }
}
export default new Vuex.Store({
    state,
    mutations
}) 
```

在helloWorld.vue中，使用这个方法 （就和自定义事件非常相似 ）

```
<template>
  <div class="hello">
    <h3>{{$store.state.count}}</h3>
    <div>
      <button @click="handleAddClick(10)">增加</button>
      <button @click="handleReduceClick(10)">减少</button>
    </div>
  </div>
</template>
methods: {
    handleAddClick(n){
      this.$store.commit('mutationsAddCount',n);
    },
    handleReduceClick(n){
      this.$store.commit('mutationsReduceCount',n);
    }
  }
```

#### 2.actions是异步操作 

创建actions对象，并且使用

这里我在两个方法中使用了两个不同的参数，一个是context，它是一个和store对象具有相同对象属性的参数。在第二个函数中，我是直接使用了这个对象的commit的方法。

```
const actions = {
    actionsAddCount(context, n = 0) {
        console.log(context)
        return context.commit('mutationsAddCount', n)
    },
    actionsReduceCount({ commit }, n = 0) {
        return commit('mutationsReduceCount', n)
    }
}
export default new Vuex.Store({
    state,
    mutations,
    actions
})
```

在helloWorld.vue中  在methods中，增加两个方法，使用dispath来触发 

```
<div>异步操作</div>
  <div>
    <button @click="handleActionsAdd(10)">异步增加</button>
    <button @click="handleActionsReduce(10)">异步减少</button>
  </div>
  handleActionsAdd(n){
      this.$store.dispatch('actionsAddCount',n)
    },
    handleActionsReduce(n){
      this.$store.dispatch('actionsReduceCount',n)
    }
```

#### 3.最后就是getters 

我们一般使用getters来获取我们的state，因为它算是state的一个计算属性 

```
const getters = {
    getterCount(state, n = 0) {
        return (state.count += n)
    }
}
export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters
})

<h4>{{count}}</h4>
const getters = {
    getterCount(state) {
        return (state.count += 10)
    }
}
```

#### 4.mapState, mapMutations, mapActions, mapGetters

vuex官方给了我们一个更简单的方式来使用vuex， 也就是 {mapState, mapMutations, mapActions, mapGetters} 

```
<script>
import {mapState, mapMutations, mapActions, mapGetters} from 'vuex'
export default {
  name: 'HelloWorld',
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  },
  methods: {
    ...mapMutations({
      handleAddClick: 'mutationsAddCount',
      handleReduceClick: 'mutationsReduceCount'
    }),
    ...mapActions({
      handleActionsAdd: 'actionsAddCount',
      handleActionsReduce: 'actionsReduceCount'
    })
    // handleAddClick(n){
    //   this.$store.commit('mutationsAddCount',n);
    // },
    // handleReduceClick(n){
    //   this.$store.commit('mutationsReduceCount',n);
    // },
    // handleActionsAdd(n){
    //   this.$store.dispatch('actionsAddCount',n)
    // },
    // handleActionsReduce(n){
    //   this.$store.dispatch('actionsReduceCount',n)
    // }
  },
  computed: {
    count(){
      return this.$store.getters.getterCount
    }
  }
}
</script>
```



## 四、关于时间的一些东西

```
var d = new Date();
d.getYear();        //获取当前年份(2位)
d.getFullYear();    //获取完整的年份(4位,1970-????)
d.getMonth();       //获取当前月份(0-11,0代表1月)
d.getDate();        //获取当前日(1-31)
d.getDay();         //获取当前星期X(0-6,0代表星期天)
d.getTime();        //获取当前时间(从1970.1.1开始的毫秒数)
d.getHours();       //获取当前小时数(0-23)
d.getMinutes();     //获取当前分钟数(0-59)
d.getSeconds();     //获取当前秒数(0-59)
d.getMilliseconds();    //获取当前毫秒数(0-999)
d.toLocaleDateString();     //获取当前日期
var mytime=d.toLocaleTimeString();     //获取当前时间
d.toLocaleString( );        //获取日期与时间
```

### 时间控件的一些操作

```
//获取时间控件的开始时间
var timeStart=new Date($("#alarmCalendar").psel().startTime)
//获取时间空间的结束时间
var timeEnd=new Date($("#alarmCalendar").psel().endTime+1000)
//格式化时间
var newtimeStart=param=='month'?timeStart.format("yyyy-M-d h:m:s"):timeStart.format("yyyy-01-01 h:m:s")
var newtimeEnd=param=='month'?timeEnd.format("yyyy-M-d h:m:s"):timeEnd.format("yyyy-12-31 h:m:s")
```

## 五、数组的一些应用

### reduce

#### 数组排序

```
//能耗管理的排序
var  sortlist = function(data){
  var _arr = data.sort(function(a,b){
    return a.energyReal < b.energyReal  ? 1 : -1;
  });
  var _eleven = _arr.splice(10,_arr.length).reduce(function(total,item){
    total.item.push(item);
    total.energyItemName="其他";
    total.energyReal += item.energyReal;
    total.energyPlan += item.energyPlan;
    total.realOccupyPlanRatio += item.realOccupyPlanRatio;
    total.realOccupyTotalRatio += item.realOccupyTotalRatio;
    return total
  },{item:[],energyReal:0,energyPlan:0,realOccupyPlanRatio:0,realOccupyTotalRatio:0});
  _arr.push(_eleven);
  return _arr;
}
```

#### 数组展开

```
//运用递归  和  reduce
var flatten = (arr, depth = 0) =>
  depth != 0
    ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), [])
    : arr.reduce((a, v) => a.concat(v), []);
flatten([1, [2, [3, [4, 5], 6], 7], 8], 2);   //输出 [1, 2, 3, 4, 5, 6, 7, 8]
```



## 六、bug总结

页面处理方面：**一定要固定好自己组件自身要占的宽度和高度**，先搭好大的框架，然后往里填东西

数据处理方面： Math.toFixed   对负数的处理容易出现 NaN  建议 用Math.abs()  先转化绝对值 或者用substr(1) 然后在数据前加一个负号

vue数据监听方面：需要先初始化数据 才能监听成功

时间控件的处理：

### 一、图表：

```
1. plotOptions: {//绘图区选项
        series: {//绘图区数列
        connectNulls: false,//是否连接一条线穿过空值点。
        stickyTracking: false,//粘连追踪
        events: {
        afterAnimate: function () {
        	$("#downday_loadpdf").show();
        	("#downday_loadpdf_copy").append(("#downday_loadpdf").clone(true));
        	var obj = {
        				container: '#downday_loadpdf',
                          downName: new Date(dayenergyModel.dateson.timeFrom).format('y年M月d日') + '日能耗分析报告',
        	}
        	pajax.downReportPdf(obj);

        }
     }
   },
},
```

### 二、数据为null,显示--

在vue的方法中使用vue的过滤器  var v_ft = this.$options.filters['discount']; 

```
例如：这种方式可以使页面更加整洁
	 listData.realOccupyBudgetRatio = listData.realOccupyBudgetRatio || listData.realOccupyBudgetRatio == 0 ? Math.toFixed({
                value: listData.realOccupyBudgetRatio,
                isByInt: true,
                isToSpecial: false
            }) : '--';
```

### 三、下载

```
解决图表未渲染完成就开始下载的问题
			plotOptions: {//绘图区选项
                                series: {//绘图区数列
                                    connectNulls: false,//是否连接一条线穿过空值点。
                                    stickyTracking: false,//粘连追踪
                                    //图表渲染完成后执行事件
                                    events: {
                                        afterAnimate: function () {
                                            $("#downday_loadpdf").show();
             $("#downday_loadpdf_copy").append($("#downday_loadpdf").clone(true));
                                            var obj = {
                                                container: '#downday_loadpdf',
                                                downName: dayenergyModel.currItemListName + new Date(dayenergyModel.dateson.timeFrom.replace(/-/g, '/')).format('y年M月d日')  + '日能耗分析报告',
                                            }
                                            pajax.downReportPdf(obj);
                                        }
                                    }
                                },
                            },

```

### 四、ie兼容

```
1.时间的兼容
.replace(/-/g, '/')   //将 2019-05-01  转化成  2019/05/01   ie的时间不识别-
在向后台发送时 转化回来
2.ie盒模型和标准盒模型
```

### 五、判断null和0

```
this.projectInfoList.info.sort(function(a,b){
    var _a = _t.isNumber(a[type]) ? a[type] : -Number.MAX_VALUE;
    var _b = _t.isNumber(b[type]) ? b[type] : -Number.MAX_VALUE;
    return _a > _b ? _order ? 1 : -1 :_order ? -1 : 1;
});
```

### 六、数据处理应注意的问题

1.数据处理应写在js中，这样会使html文件更加整洁

 	例如 $options.filters. 过滤器名称 写在页面上会使延长页面加载时间   建议数据处理 及判断写在js中

2.方法应尽量避免重复

3.数据处理及图表的处理 写到接口请求成功后就行

### 七、方法的使用

```
	// 获取该月第一天
    getMonthFirstDay: function(timeObj){
        timeObj.setDate(1);
        timeObj.setHours(0);
        timeObj.setMinutes(0);
        timeObj.setSeconds(0);
        timeObj.setMilliseconds(0);
        return timeObj;
    },
    // 获取该月最后一天
    getMonthLastDay: function(timeObj){
        var _month = timeObj.getMonth();
        var _lastMonth = _t.getMonthFirstDay(timeObj).setMonth(_month + 1);
        return new Date(_lastMonth - 1);
    },
    // 获取12个月后的时间
    getLastYear: function(timeObj){
        var _year = timeObj.getFullYear();
        var _month = timeObj.getMonth();
        if(_month === 11){
            _month = 0;
        }else{
            _year--;
            _month++;
        }
        timeObj.setFullYear(_year);
        timeObj.setMonth(_month);
        return timeObj;
    },
    /*
     *  获取百分比的颜色
     *  @value {String} 带%的百分比
     *  @type {Number} 数据类型
     */
    getPercentColor: function(value,type){
        if(value === '--' || value === '--%'){ return ''; }
        if(value == 0 || value == '0%'){ return 'green'; }
        switch(type){
            // 带正负符号，正为红，负为绿
            case 0:
                return value.indexOf('+') > -1 ? 'red' : parseFloat(value) == 0 ? '' : 'green';
            // 不带正负符号 大于100%为红，小于100%为绿
            case 1:
                value = value.replace(/[^-.0-9]/g,'');
                // value = value.replace(/,/g,'');
                return parseFloat(value) >= 100 ? 'red' : parseFloat(value) == 0 ? '' : 'green';
        }
    },
```

#### 	实用的小技巧

#### **7.1 string强制转换为数字**

```

```

#### 7.2 使用Boolean过滤数组中的所有假值

```
我们知道JS中有一些假值：false，null，0，""，undefined，NaN，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换
const compact = arr => arr.filter(Boolean)
compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34])             // [ 1, 2, 3, 'a', 's', 34 ]
```

#### 7.3短路运算符

```  
可以增加代码的容错率 
&amp;&amp;为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值
||为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值
短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了；
var a
var arr=a||[]
console.log(arr)   //[]
如果接口请求的是对象   var arr=a||{}
```

#### 7.4取整 `| 0`

```
对一个数字| 0可以取整，负数也同样适用，num | 0
1.3 | 0         // 1
-1.9 | 0        // -1
```

#### 7.5数字补0操作

```
有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用slice和string的padStart方法
const addZero1 = (num, len = 2) => (`0${num}`).slice(-len)
const addZero2 = (num, len = 2) => (`${num}`).padStart( len   , '0')
addZero1(3) // 03

addZero2(32,4)  // 0032
```

#### 7.6reduce方法同时实现map和filter

```
const numbers = [10, 20, 30, 40];
const doubledOver50 = numbers.reduce((finalList, num) => {
  num = num * 2;
  if (num > 50) {
    finalList.push(num);
  }
  return finalList;
}, []);
doubledOver50;            // [60, 80]
```

### 7.7统计数组中相同项的个数

```
var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];
var carsObj = cars.reduce(function (obj, name) {
  obj[name] = obj[name] ? ++obj[name] : 1;
  return obj;
}, {});
carsObj; // => { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }
```



### 八、正则表达式

```
正则表达式(regular expression)
	描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。
. 匹配除/n外的所有字符
选择：
	用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。
反向引用：
	对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
```

正则表达式

```
1、匹配整数或者小数（包括正数和负数）    -?\d+(\.\d+)?

```